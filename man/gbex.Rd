% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/1. gradient_boosting_functions.R
\name{gbex}
\alias{gbex}
\title{GPD boosting}
\usage{
gbex(
  y,
  X,
  B = 100,
  lambda = NULL,
  lambda_ratio = 10,
  lambda_scale = 0.01,
  depth = c(1, 1),
  min_leaf_size = c(30, 30),
  sf = 0.75,
  gamma_positive = T,
  silent = F,
  VI_type = NULL
)
}
\arguments{
\item{y}{Response variables (vector of length n)}

\item{X}{Covariate matrix (matrix of dimension (n x d))}

\item{B}{Number of gradient boosting steps}

\item{lambda}{learning rate for the scale and shape parameter}

\item{lambda_ratio}{the ratio of the lambda_sigma/lambda_gamma (Use this together with lambda_scale, see details)}

\item{lambda_scale}{equal to the suze of lambda_sigma  (Use this together with lambda_scale, see details)}

\item{depth}{Maximum depth of the trees}

\item{sf}{sample fraction used for fitting the trees}

\item{gamma_positive}{boolean indicating whether gamma should be positive}

\item{silent}{boolean indicating whether progress during fitting procedure should be printed.}

\item{VI_type}{character vector indicating which variable importance should be calculated (when VI_type = NULL no variable importance is calculated)}
}
\value{
gbex returns an object of class "gbex" which contains the following components:
\item{theta}{Data frame with the estimated gamma and sigma parameter for each observation}
\item{dev}{Numeric with deviance of model}
\item{trees_sigma}{List with gradient_tree objects for sigma}
\item{trees_gamma}{List with gradient_tree objects for gamma}
\item{lambda}{Numeric with the learining rate of sigma and gamma}
\item{B}{Numeric with number of trees}
\item{depth}{Numeric with maximum tree depth for sigma and gamma}
}
\description{
Estimate the Generalized Pareto distribution conditional on covariates using a boosting procedure.
}
\details{
Instead of specifying the learning rates lambda for sigma and gamma seperately the ratio of the two can be specified together with the size of the first one.
This can be done using lambda_ratio and lambda_scale. The used lambda is then given by lambda_scale*(1,1/lambda_ratio).
}
